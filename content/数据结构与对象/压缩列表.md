### 压缩列表

压缩列表(`ziplist`)是列表键和哈希键的底层实现之一。

当一个列表键只包含少量列表项，并且每个列表项要么就是小整数值，

要么就是长度比较短的字符串，那么`Redis`就会使用压缩列表来做列表键的底层实现。

同样，当一个哈希键只包含少量键值对，并且每个键值对的键和值要么是小整数值，

要么是长度比较短的字符串，`Redis`就会使用压缩列表来做哈希键的底层实现。

```c
> RPUSH lst 1 3 5 10086 "hello world"
(integer) 6
> OBJECT ENCODING lst
"ziplist"
    
> HMSET profile "name" "Jack" "age" 28 "job" "Programmer"
OK
> OBJECT ENCODING profile
"ziplist"
```



#### 压缩列表的构成

压缩列表是`Redis`为了节约内存而开发的，是由一系列特殊编码的连续内存块组成的

顺序型(`sequential`)数据结构。一个压缩列表可以包含任意多个节点(`entry`)，

每个节点可以保存一个字节数组或者一个整数值。 



#### 压缩列表节点的构成

由三部分组成

* `previous_entry_length`

  记录**前一个节点**的长度，用于往前遍历。（根据当前节点的起始地址计算前一个节点的起始地址）

  如果前一个节点的长度在小于254字节，则用1字节表示，否则用5个字节表示。

  5个字节表示时，第一个字节的值固定为`0xFE`，之后的值为字节的长度。

* `encoding`

  保存数据的类型以及长度

* `content`

  保存节点的值，可以是一个字节数组或者整数。由`encoding`属性决定



####  连锁更新

有e1至eN个长度介于250字节到253字节的连续节点。e1为表头节点。

因为长度都小于254，因此`previous_entry_length`只需使用1个节点，来存储上个节点的长度。

此时如果将一个长度大于253的节点设置为压缩列表新的表头节点，由于长度大于253，

因此需要5字节存储长度，即e1需要另外扩展4个字节，用于存上一个节点的长度。

扩展之后e1的长度也大于253了，因此e2也需要扩展4个字节，存e1的长度。

扩展之后e2的长度也大于253了，因此e3也需要扩展4个字节，存e2的长度。

这就是连锁更新问题。

> 除了添加新节点会引发连锁更新，删除节点也可能引发连锁更新。

连锁更新在最坏情况下需要对压缩列表执行N次空间重分配操作，而每次空间重分配的

最坏复杂度为O(N)，所以连锁更新的最坏复杂度为O(N^2)。

尽管连锁更新的复杂度较高，但真正造成性能问题的几率很低

* 首先，压缩列表里要恰好有多个连续的、长度介于250字节至253字节之间的节点。
* 其次，即使出现连锁更新，只要被更新的节点数量不多，就不会对性能造成任何影响。

